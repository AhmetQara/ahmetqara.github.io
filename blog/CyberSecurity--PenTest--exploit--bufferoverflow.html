<!doctype html>
<html>
<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
  <title>bufferoverflow</title>
  <meta name="generator" content="CherryTree">
  <link rel="stylesheet" href="res/styles4.css" type="text/css" />
</head>
<body>
<div class='page'><h1 class='title'>bufferoverflow</h1><br/><br /><br />1- spiking (sunucuyu çökertebiliyor muyuz ona bakarız)<br />2- fuzzing yaparız yani sunucuya bir sürü karakter yollayıp kaç karakterle çökertebiliyoruz onu buluruz<br />3- offset ile tam olarak kaçıncı karakterde çöktüğünü tespit ederiz. bu noktadan sonra exploiti yazmaya hazır oluruz.   <br />→ offset işlemini kali de genelde  “usr/share/metasploit-framework/tools/exploit” kısmında bulunan “pattern_create.rb” programı ile bir karakter pattern&#39;i oluştururuz örneğin “./pattern_create.rb -l 7000&quot; diyerek 7000 karakterli bir pattern oluşturduk. Ardından bu karakter dizisi içerisinde immunite debugger gibi bir program ile sunucunun çöktüğü anda alınan “386F4337” gibi bir “EIP 386F4337” EIP değeri alırız ve bu değeri kalide pattern_create.rb gibi benzer bir exploit tool olan pattern_offset.rb yi “./pattern_offset.rb -l 7000 -q 386F4337” bu şekilde kullanarak sunucunun tam olarak kaçıncı karakter gönderiminde çöktüğünü buluruz. <br /><br /><img src="images/28-1.png" alt="images/28-1.png" /><br /><br />  Böylelikle 2003. değere geldiğimizde biz ne yazarsak yani koyacağımız değer ne olursa EIP değerine son olarak o yazılacak bu şekilde tam bufferoverflow olduğu anda EIP değerine istediğimiz şeyi yazdırarak yani istediğimiz kodu koyarak içeriye sızabileceğiz. Yani EIP&#39;ye istediğimiz kodu yazdırıp onu çalıştırmasını söylemiş olabileceğiz.<br /><br />EIP gösterimi aşağıdadır:<br /><br /><img src="images/28-2.png" alt="images/28-2.png" /><br /><br /><br />  bundan sonra artık EIP kısmında reverse shell yaparak bağlantı açabiliriz. Bunu ise RAM kısmında çalıştıracağımız için assembly olarak yollamamız gerekiyor ki instruction olarak RAM&#39;de çalıştırabilelim. Bunu da msfvenom gibi tool&#39;lar sayesinde yapabiliyoruz. Bunu yaparken çalışmayabilecek olan karakterleri çıkartmamız gerekiyor yani “badcharacters” kontrolü yapmalıyız.<br /><br /><img src="images/28-3.png" alt="images/28-3.png" /><br /><br />yukarıdaki şekilde bir badChar gönderip sunucuda kontrol yapmalıyız (bad character kontrolü için). <br /><br /><img src="images/28-4.png" alt="images/28-4.png" /><br /><br /> örneğin yukarıda ki gibi bir sonucu sonuna kadar inceleyip geçişlerde bir kopukluk var mı yok mu diye kontrol etmeliyiz. 01,02,03 diye giderken eğer mesela 04&#39;den 06&#39;ya atlamışsa o arada bir badcharacter vardır onu o zaman kullanmamalıyız. Bir badcharacter örneği; “x00” vb gibi. Bu şekilde bad Character kontrolü yapmış oluyoruz.<br /><br />bu pencerede o seçili yeri göstermek için ise aşağıda gösterilen ESP kısmına gelip bi kere tıklayıp mavi şekilde seçtikten sonra → <br /><br /><img src="images/28-5.png" alt="images/28-5.png" /><br /><br />→ sağ tık yapıp “Follow in Dump” dedikten sonra → <br /><br /><img src="images/28-6.png" alt="images/28-6.png" /><br /><br />→ bizi bu yere götürecek ve bu seçili kısımda badcharacter kontrolü yapabiliriz.<br /><br /><img src="images/28-7.png" alt="images/28-7.png" /><br /><br />  Şimdi gelelim assembly kodlarını hex kodlarına dönüştürmeye. Yine “usr/share/metasploit-framework/tools/exploit” kısmında bulunan  “nasm_shell.rb” ile bunu yapabiliyoruz. Mesela biz bu durumda “JMP ESP” kodunu hex koda çevirelim;<br /><br /><img src="images/28-8.png" alt="images/28-8.png" /> çeviri çıktısı olarak “FFE4” elde ettik. Bu hex kodu immunity debugger içine bir mona python modülü yükledikten sonra aratacağız.<br /><br /><br />  immunity debugger içine mona python modülünü indirip içine attıktan sonra alt kısımda bulunan konsola “!mona modules” yazıp enter&#39;a basınca karşımıza aşağıdaki gibi bir pencere açılacak.<br /><br /><img src="images/28-9.png" alt="images/28-9.png" /> <br /><br />consol&#39;un yeri burada. buraya “!mona modules” yazıp enter&#39;a basıyoruz ve aşağıda ki pencere açılacak;<br /><br /><img src="images/28-10.png" alt="images/28-10.png" /><br />  <br />  burada örneğin ilk satırda olan “essfunc.dll” gibi “False” olan yerlerdeki bu dosyalarda memory koruması yok demektir ve hacklemek istediğimiz servisle beraber çalışıyor. Eğer biz burada bir “JUMP ESP” kodu bulabilirsek ve o kodu kullanarak bir işlem yapabilirsek o zaman istediğimiz sonuca varabiliriz. Biz zaten “nasm_shell.rb&quot; sayesinde bu hex kodu almıştık<br />  <br />   <img src="images/28-11.png" alt="images/28-11.png" /> bu şekilde elde etmiştik “FFE4” kodunu aratalım.<br /><br /><img src="images/28-12.png" alt="images/28-12.png" /> console kısmına bu şekilde yazarak ve bu “FFE4” yani “JMP ESP” kodunun çalıştığı modül olarak “essfunc.dll” seçerek bu şekilde aratma yapıyoruz. (Hatırlatma: essfunc.dll modülünü üstte ki pencerede “FALSE” yazan ilk satırdan elde etmiştik.)<br /><br />Arama tamamlandıktan sonra;<br /><br /><img src="images/28-13.png" alt="images/28-13.png" /><br /><br />  böyle bir sonuç geliyor. Demek ki bu adreslerde  “JMP ESP” kodu çalıştırılıyormuş. Eğer bu adresi kullanarak EIP&#39;ye bir komut verebilirsem, göstereceğim bir shell koda yönlendirme yapabilirim yani reverse shell işlemim başarılı olmuş ve içeri sızmış olurum.  Not: burada ki tüm adresleri tek tek denemek gerekebilir. <br /><br /> Şimdi msfvenom ile revers shell karakter kodu oluşturalım.<br /><br /><img src="images/28-14.png" alt="images/28-14.png" /> <br /><br /> bu şekilde yazarak kodu çalıştırıyoruz. <br /><br /><img src="images/28-15.png" alt="images/28-15.png" /> <br /><br />  Bu gördüğümüz işaretli kısım aslında bizim için oluşturulmuş biz backdoor yani zararlı bir yazılım. Bu görülen hex hali ve bu assembly instruction&#39;larına dönüştürülerek çalıştırılacak. Şimdi bunu kopyalayıp string olarak sunucuya göndereceğiz, tam bufferoverflow ettiği anda bu zararlı string çalışıp reverse shell yaparak bize bağlanıp içeriye erişim verecek, böylelikle sunucuyu hacklemiş olacağız. </div>
</body>
</html>
